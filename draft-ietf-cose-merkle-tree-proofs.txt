



COSE                                                           O. Steele
Internet-Draft                                                 Transmute
Intended status: Standards Track                             H. Birkholz
Expires: 30 March 2025                                    Fraunhofer SIT
                                                      A. Delignat-Lavaud
                                                              C. Fournet
                                                               Microsoft
                                                       26 September 2024


                             COSE Receipts
               draft-ietf-cose-merkle-tree-proofs-latest

Abstract

   COSE (CBOR Object Signing and Encryption) Receipts prove properties
   of a verifiable data structure to a verifier.  Verifiable data
   structures and associated proof types enable security properties,
   such as minimal disclosure, transparency and non-equivocation.
   Transparency helps maintain trust over time, and has been applied to
   certificates, end to end encrypted messaging systems, and supply
   chain security.  This specification enables concise transparency
   oriented systems, by building on CBOR (Concise Binary Object
   Representation) and COSE.  The extensibility of the approach is
   demonstrated by providing CBOR encodings for RFC9162.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Discussion of this document takes place on the CBOR Object Signing
   and Encryption Working Group mailing list (cose@ietf.org), which is
   archived at https://mailarchive.ietf.org/arch/browse/cose/.

   Source for this draft and an issue tracker can be found at
   https://github.com/cose-wg/draft-ietf-cose-merkle-tree-proofs.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 30 March 2025.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
     1.1.  Requirements Notation
   2.  CBOR Tags
   3.  Terminology
   4.  Verifiable Data Structures in CBOR
     4.1.  Structures
     4.2.  Parameters
     4.3.  Usage
       4.3.1.  Registration Requirements
   5.  RFC9162_SHA256
     5.1.  Verifiable Data Structure
     5.2.  Inclusion Proof
       5.2.1.  Receipt of Inclusion
     5.3.  Consistency Proof
       5.3.1.  Receipt of Consistency
   6.  Privacy Considerations
     6.1.  Log Length
     6.2.  Header Parameters
   7.  Security Considerations
     7.1.  Choice of Signature Algorithms
     7.2.  Validity Period
     7.3.  Status Updates
   8.  Acknowledgements
   9.  IANA Considerations
     9.1.  Additions to Existing Registries
       9.1.1.  New Entries to the COSE Header Parameters Registry
       9.1.2.  COSE Verifiable Data Structures
       9.1.3.  COSE Verifiable Data Structure Parameters
   10. References
     10.1.  Normative References
     10.2.  Informative References
   Appendix A.  Implementation Status
     A.1.  Implementer
     A.2.  Implementation Name
     A.3.  Implementation URL
     A.4.  Maturity
     A.5.  Coverage and Version Compatibility
     A.6.  License
     A.7.  Implementation Dependencies
     A.8.  Contact
   Authors' Addresses

1.  Introduction

   COSE Receipts are signed proofs that include metadata about about
   certain states of a verifiable data structure (VDS) that are true
   when the COSE Receipt was issued.  COSE Receipts can include proves
   that a document is in a database (proof of inclusion), that a
   database is append only (proof of consistency), that a smaller set of
   statements are contained in a large set of statements (proof of
   disclosure, a special case of proof of inclusion), or proof that
   certain data is not yet present in a database (proofs of non
   inclusion).  Different VDS can produce different verifiable data
   structure proofs (VDP).  The combination of representations of
   various VDS and VDP can significantly increase burden for
   implementers and create interoperability challenges for transparency
   services.  This document describes how to convey VDS and associated
   VDP types in unified COSE envelopes.

1.1.  Requirements Notation

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

2.  CBOR Tags

   Editorial Note (To be removed by RFC Editor).

   This section will be removed before the document is completed, its
   purpose is to track the TBD code points references throughout the
   draft.

   395 is TBD_1:  A requested cose header parameter representing the
      verifiable data structure used.

   396 is TBD_2:  A requested cose header parameter representing the
      verifiable data structure parameters map (proofs map).

   The other codepoints are assigned from the registries established in
   this draft, they are therefore not marked TBD.

3.  Terminology

   CDDL:  Concise Data Definition Language (CDDL) is defined in
      [RFC8610].

   EDN:  CBOR Extended Diagnostic Notation (EDN) is defined in
      [RFC8949], where it is referred to as "diagnostic notation", and
      is revised in [I-D.draft-ietf-cbor-edn-literals].

   Verifiable Data Structure (VDS):  A data structure which supports one
      or more Proof Types.  This property is conceptually similar to
      "alg" (1), it described an algorithm used to maintain the
      verifiable data structure, for example a binary merkle tree
      algorithm.

   Verifiable Data Structure Parameters (VDP):  Parameters to a
      verifiable data structure that are used to prove properties, such
      as authentication, inclusion, consistency, and freshness.
      Parameters can include multiple proofs of a given type, or
      multiple types of proof (inclusion and consistency).  This
      property is conceptually similar to COSE Header Parameter "epk"
      (-1) or CBOR Web Token (CWT) claim "cnf" (8), it is applied to a
      verifiable data structure, to confirm a property.  For example an
      encrypted message might be decrypted using epk and a private key,
      a digital signature for authentication might be verified using cnf
      and the (CWT) claim "nonce" and "audience", and an inclusion proof
      for a binary merkle tree might be verified with VDP and some entry
      that is being tested or inclusion in the tree.

   Proof Type:  A verifiable process, that proves properties of a
      Verifiable Data Structure.  For example, a VDS, such as a binary
      merkle tree, can support multiple proofs of type "inclusion" where
      each proof confirms that a given entry is included in a merkle
      root.

   Proof Value:  An encoding of a Proof Type in CBOR.

   Entry:  An entry in a verifiable data structure for which proofs can
      be derived.

   Receipt:  A COSE object, as defined in [RFC9052], containing the
      header parameters necessary to convey VDP for an associated VDS.

4.  Verifiable Data Structures in CBOR

   This section describes representations of verifiable data structure
   proofs in CBOR.  For example, construction of a merkle tree leaf, or
   an inclusion proof from a leaf to a merkle root, might have several
   different representations, depending on the verifiable data structure
   used.  Differences in representations are necessary to support
   efficient verification, unique security or privacy properties, and
   for compatibility with specific implementations.  This document
   defines two extension points for enabling verifiable data structures
   with COSE and provides concrete examples for the structures and
   proofs defined in [RFC9162].  The design of these structures is
   influenced by the conventions established for COSE Keys.

   During testing and development the experimental range SHOULD be used,
   unless early assignment for a provisional entry has been completed.

4.1.  Structures

   Similar to COSE Key Types (https://www.iana.org/assignments/cose/
   cose.xhtml#key-type), different verifiable data structures support
   different algorithms.  As EC2 keys (1: 2) support both digital
   signature and key agreement algorithms, RFC9162_SHA256 (TBD_1 : 1)
   supports both inclusion and consistency proofs.

   This document establishes a registry of verifiable data structure
   algorithms, with the following initial contents:

   +================+=======+===========================+===========+
   | Name           | Value | Description               | Reference |
   +================+=======+===========================+===========+
   | N/A            | 0     | N/A                       | N/A       |
   +----------------+-------+---------------------------+-----------+
   | RFC9162_SHA256 | 1     | SHA256 Binary Merkle Tree | [RFC9162] |
   +----------------+-------+---------------------------+-----------+
   | EXPERIMENTAL   | 11    | Unknown                   | RFC XXXX  |
   +----------------+-------+---------------------------+-----------+
   | EXPERIMENTAL   | 22    | Unknown                   | RFC XXXX  |
   +----------------+-------+---------------------------+-----------+
   | EXPERIMENTAL   | 33    | Unknown                   | RFC XXXX  |
   +----------------+-------+---------------------------+-----------+

                Table 1: COSE Verifiable Data Structures

   When designing new verifiable data structures, please request the
   next available positive integer as your requested assignment, for
   example:

   +================+================+===============+===============+
   | Name           | Value          | Description   | Reference     |
   +================+================+===============+===============+
   | N/A            | 0              | N/A           | N/A           |
   +----------------+----------------+---------------+---------------+
   | RFC9162_SHA256 | 1              | SHA256 Binary | [RFC9162]     |
   |                |                | Merkle Tree   |               |
   +----------------+----------------+---------------+---------------+
   | Your name      | TBD (requested | tbd           | Your          |
   |                | assignment 2)  |               | specification |
   +----------------+----------------+---------------+---------------+

                 Table 2: How to register new structures

4.2.  Parameters

   Similar to COSE Key Type Parameters
   (https://www.iana.org/assignments/cose/cose.xhtml#key-type-
   parameters), as EC2 keys (1: 2) keys require and give meaning to
   specific parameters, such as -1 (crv), -2 (x), -3 (y), -4 (d),
   RFC9162_SHA256 (TBD_1 : 1) supports both (-1) inclusion and (-2)
   consistency proofs.

   This document establishes a registry of verifiable data structure
   algorithms, with the following initial contents:

   +============+=============+=====+=======+=============+===========+
   | Verifiable | Name        |Label| CBOR  | Description | Reference |
   | Data       |             |     | Type  |             |           |
   | Structure  |             |     |       |             |           |
   +============+=============+=====+=======+=============+===========+
   | 1          | inclusion   |-1   | array | Proof of    | Section   |
   |            | proofs      |     | (of   | inclusion   | 5.2       |
   |            |             |     | bstr) |             |           |
   +------------+-------------+-----+-------+-------------+-----------+
   | 1          | consistency |-2   | array | Proof of    | Section   |
   |            | proofs      |     | (of   | append only | 5.3       |
   |            |             |     | bstr) | property    |           |
   +------------+-------------+-----+-------+-------------+-----------+
   | 11         | unknown     |-1   | array | Unknown     | RFC XXXX  |
   |            |             |     | (of   |             |           |
   |            |             |     | bstr) |             |           |
   +------------+-------------+-----+-------+-------------+-----------+
   | 22         | unknown     |-1   | array | Unknown     | RFC XXXX  |
   |            |             |     | (of   |             |           |
   |            |             |     | bstr) |             |           |
   +------------+-------------+-----+-------+-------------+-----------+
   | 33         | unknown     |-1   | array | Unknown     | RFC XXXX  |
   |            |             |     | (of   |             |           |
   |            |             |     | bstr) |             |           |
   +------------+-------------+-----+-------+-------------+-----------+

            Table 3: COSE Verifiable Data Structure Parameters

   Proof types are specific to their associated "verifiable data
   structure", for example, different Merkle trees might support
   different representations of "inclusion proof" or "consistency
   proof".  Implementers should not expect interoperability across
   "verifiable data structures", but they should expect conceptually
   similar properties across the different registered proof types.  For
   example, 2 different merkle tree based verifiable data structures
   might both support proofs of inclusion.  Security analysis SHOULD be
   conducted prior to migrating to new structures to ensure the new
   security and privacy assumptions are acceptable for the use case.
   When designing new verifiable data structure parameters (or proof
   types), please start with -1, and count down for each proof type
   supported by your verifiable data structure:

   +==========+===========+=====+=====+===========+==================+
   |Verifiable|Name       |Label|CBOR |Description|Reference         |
   |Data      |           |     |Type |           |                  |
   |Structure |           |     |     |           |                  |
   +==========+===========+=====+=====+===========+==================+
   |1         |inclusion  |-1   |array|Proof of   |Section 5.2       |
   |          |proofs     |     |(of  |inclusion  |                  |
   |          |           |     |bstr)|           |                  |
   +----------+-----------+-----+-----+-----------+------------------+
   |1         |consistency|-2   |array|Proof of   |Section 5.3       |
   |          |proofs     |     |(of  |append only|                  |
   |          |           |     |bstr)|property   |                  |
   +----------+-----------+-----+-----+-----------+------------------+
   |TBD       |new proof  |-1   |tbd  |tbd        |Your_Specification|
   |(requested|type       |     |     |           |                  |
   |assignment|           |     |     |           |                  |
   |2)        |           |     |     |           |                  |
   +----------+-----------+-----+-----+-----------+------------------+
   |TBD       |new proof  |-2   |tbd  |tbd        |Your_Specification|
   |(requested|type       |     |     |           |                  |
   |assignment|           |     |     |           |                  |
   |2)        |           |     |     |           |                  |
   +----------+-----------+-----+-----+-----------+------------------+
   |TBD       |new proof  |-3   |tbd  |tbd        |Your_Specification|
   |(requested|type       |     |     |           |                  |
   |assignment|           |     |     |           |                  |
   |2)        |           |     |     |           |                  |
   +----------+-----------+-----+-----+-----------+------------------+

                 Table 4: How to register new parameters

4.3.  Usage

   This document registered a new COSE Header Parameter receipts (394)
   to enable this Receipts to be conveyed in the protected and
   unprotected headers of COSE Objects.

   When the receipts parameter is present, the associated verifiable
   data structure and verifiable data structure proofs MUST match
   entries present in the registries established in RFC XXXX.

   The following informative CDDL is provided:

   Receipt = #6.18(COSE_Sign1)

   Protected_Header = {
     * cose-label => cose-value
   }

   Unprotected_Header = {
     &(receipts: 394)  => [+ Receipt]
     * cose-label => cose-value
   }

   COSE_Sign1 = [
     protected   : bstr .cbor Protected_Header,
     unprotected : Unprotected_Header,
     payload     : bstr / nil,
     signature   : bstr
   ]

           Figure 1: CDDL for a COSE Sign1 with attached receipts

   The following informative EDN is provided:

   18(                                 / COSE Sign 1                   /
       [
         h'a4012603...6d706c65',       / Protected                     /
         {                             / Unprotected                   /
           394: [                      / Receipts (2)                  /
             h'd284586c...4191f9d2'    / Receipt 1                     /
             h'c624586c...8f4af97e'    / Receipt 2                     /
           ]
         },
         nil,                          / Detached payload              /
         h'79ada558...3a28bae4'        / Signature                     /
       ]
   )

           Figure 2: EDN for a COSE Sign1 with attached receipts

4.3.1.  Registration Requirements

   Each specification MUST define how to encode the verifiable data
   structure and its parameters (also called proof types) in CBOR.  Each
   specification MUST define how to produce and consume the supported
   proof types.  See Section 5 as an example.

   Where a specification supports a choice of hash algorithm, an IANA
   registration must be made for each individually supported algorithm.
   For example, to provide for both SHA256 and SHA3_256 with [RFC9162],
   both "RFC9162_SHA256" and "RFC9162_SHA3_256" require entries in the
   relevant IANA registries.

5.  RFC9162_SHA256

   This section defines how the data structures described in [RFC9162]
   are mapped to the terminology defined in this document, using CBOR
   and COSE.

5.1.  Verifiable Data Structure

   The integer identifier for this Verifiable Data Structure is 1.  The
   string identifier for this Verifiable Data Structure is
   "RFC9162_SHA256".  See Table 1.  See [RFC9162], 2.1.1.  Definition of
   the Merkle Tree, for a complete description of this verifiable data
   structure.

5.2.  Inclusion Proof

   See [RFC9162], 2.1.3.1.  Generating an Inclusion Proof, for a
   complete description of this verifiable data structure proof type.

   The CBOR representation of an inclusion proof for RFC9162_SHA256 is:

   inclusion-proof = bstr .cbor [

       ; tree size at current merkle root
       tree-size: uint

       ; index of leaf in tree
       leaf-index: uint

       ; path from leaf to current merkle root
       inclusion-path: [ + bstr ]
   ]

               Figure 3: CBOR Encoded RFC9162 Inclusion Proof

   The term leaf-index is used for alignment with the use established in
   [RFC9162]

   Note that [RFC9162] defines that verification MUST fail if leaf-index
   is >= tree-size, and inclusion proofs are defined only for leaf
   nodes.  The identifying index of a leaf node is relative to all nodes
   in the tree size for which the proof was obtained.

5.2.1.  Receipt of Inclusion

   In a signed inclusion proof, the payload is the merkle tree root
   which corresponds to the log at size tree-size.  Specifications are
   encouraged to make payloads detached when possible, forcing
   validation-time comparison.  Profiles of proof signatures are
   encouraged to make additional protected header parameters mandatory,
   to ensure that claims are processed with their intended semantics.
   One way to include this information in the COSE structure is use of
   the typ (type) Header Parameter, see
   [I-D.ietf-cose-typ-header-parameter] and the similar guidance
   provided in [I-D.ietf-cose-cwt-claims-in-headers].  The protected
   header for an RFC9162_SHA256 inclusion proof signature is:

   protected-header-map = {
     &(alg: 1) => int
     &(vds: 395) => int
     * cose-label => cose-value
   }

           Figure 4: Protected Header for a Receipt of Inclusion

   *  alg (label: 1): REQUIRED.  Signature algorithm identifier.  Value
      type: int.

   *  vds (label: 395): REQUIRED. verifiable data structure algorithm
      identifier.  Value type: int.

   The unprotected header for an RFC9162_SHA256 inclusion proof
   signature is:

   inclusion-proofs = [ + inclusion-proof ]

   verifiable-proofs = {
     &(inclusion-proof: -1) => inclusion-proofs
   }

   unprotected-header-map = {
     &(vdp: 396) => verifiable-proofs
     * cose-label => cose-value
   }

   Figure 5: A Verifiable Data Structure Proofs in an Unprotected Header

   *  vdp (label: 396): REQUIRED.  Verifiable data structure proofs.
      Value type: Map.

   *  inclusion-proof (label: -1): REQUIRED.  Inclusion proofs.  Value
      type: Array of bstr.

   The payload of an RFC9162_SHA256 inclusion proof signature is the
   Merkle tree hash as defined in [RFC9162].  The payload MUST be
   detached.  Detaching the payload forces verifiers to recompute the
   root from the inclusion proof, this protects against implementation
   errors where the signature is verified but the merkle root does not
   match the inclusion proof.  The EDN for a Receipt containing an
   inclusion proof for RFC9162_SHA256 is:

   18(                                 / COSE Sign 1                   /
       [
         h'a4012604...6d706c65',       / Protected                     /
         {                             / Unprotected                   /
           396: {                      / Proofs                        /
             -1: [                     / Inclusion proofs (1)          /
               h'83080783...32568964', / Inclusion proof 1             /
             ]
           },
         },
         nil,                          / Detached payload              /
         h'2e34df43...8d74d55e'        / Signature                     /
       ]
   )

                    Figure 6: Example inclusion receipt

   The EDN for the Protected Header in the example above is:

   {                                   / Protected                     /
     1: -7,                            / Algorithm                     /
     4: h'4930714e...7163316b',        / Key identifier                /
     395: 1,                           / Verifiable Data Structure     /
   }

        Figure 7: Example inclusion receipt decoded protected header

   The VDS in the protected header is necessary to understand the VDP in
   the unprotected header.

   The EDN for the inclusion proof in the Unprotected Header is:

   [                                   / Inclusion proof 1             /
     8,                                / Tree size                     /
     7,                                / Leaf index                    /
     [                                 / Inclusion hashes (3)          /
        h'2a8d7dfc...15d10b22'         / Intermediate hash 1           /
        h'75f177fd...2e73a8ab'         / Intermediate hash 2           /
        h'0bdaaed3...32568964'         / Intermediate hash 3           /
     ]
   ]

        Figure 8: Example inclusion receipt decoded inclusion proof

   The VDS in the protected header is necessary to understand the
   inclusion proof structure in the unprotected header.

   The inclusion proof and signature are verified in order.  First the
   verifiers applies the inclusion proof to a possible entry (set
   member) bytes.  If this process fails, the inclusion proof may have
   been tampered with.  If this process succeeds, the result is a merkle
   root, which in the attached as the COSE Sign1 payload.  Second the
   verifier checks the signature of the COSE Sign1.  If the resulting
   signature verifies, the Receipt has proved inclusion of the entry in
   the verifiable data structure.  If the resulting signature does not
   verify, the signature may have been tampered with.  It is recommended
   that implementations return a single boolean result for Receipt
   verification operations, to reduce the chance of accepting a valid
   signature over an invalid inclusion proof.

5.3.  Consistency Proof

   See [RFC9162], 2.1.4.1.  Generating a Consistency Proof, for a
   complete description of this verifiable data structure proof type.

   The cbor representation of a consistency proof for RFC9162_SHA256 is:

   consistency-proof =  bstr .cbor [

       ; older merkle root tree size
       tree-size-1: uint

       ; newer merkle root tree size
       tree-size-2: uint

       ; path from older merkle root to newer merkle root.
       consistency-path: [ + bstr ]

   ]

              Figure 9: CBOR Encoded RFC9162 Consistency Proof

   Editors note: tree-size-1, could be omitted, if an inclusion-proof is
   always present, since the inclusion proof contains, tree-size-1.

5.3.1.  Receipt of Consistency

   In a signed consistency proof, the newer merkle tree root (proven to
   be consistent with an older merkle tree root) is an attached payload
   and corresponds to the log at size tree-size-2.

   The protected header for an RFC9162_SHA256 consistency proof
   signature is:

   protected-header-map = {
     &(alg: 1) => int
     &(vds: 395) => int
     * cose-label => cose-value
   }

          Figure 10: Protected Header for a Receipt of Consistency

   *  alg (label: 1): REQUIRED.  Signature algorithm identifier.  Value
      type: int.

   *  vds (label: TBD_1): REQUIRED.  Verifiable data structure algorithm
      identifier.  Value type: int.

   The unprotected header for an RFC9162_SHA256 consistency proof
   signature is:

   consistency-proofs = [ + consistency-proof ]

   verifiable-proofs = {
     &(consistency-proof: -2) => consistency-proofs
   }

   unprotected-header-map = {
     &(vdp: 396) => verifiable-proofs
     * cose-label => cose-value
   }

   *  vdp (label: 396): REQUIRED.  Verifiable data structure proofs.
      Value type: Map.

   *  consistency-proof (label: -2): REQUIRED.  Consistency proofs.
      Value type: Array of bstr.

   The payload of an RFC9162_SHA256 consistency proof signature is: The
   newer Merkle tree hash as defined in [RFC9162].  The payload MUST be
   attached.

   The EDN for a Receipt containing a consistency proof for
   RFC9162_SHA256 is:

   18(                                 / COSE Sign 1                   /
       [
         h'a3012604...392b6601',       / Protected                     /
         {                             / Unprotected                   /
           396: {                      / Proofs                        /
             -2: [                     / Consistency proofs (1)        /
               h'83040682...2e73a8ab', / Consistency proof 1           /
             ]
           },
         },
         h'430b6fd7...f74c7fc4',       / Payload (Attached)            /
         h'd97befea...f30631cb'        / Signature                     /
       ]
   )

                   Figure 11: Example consistency receipt

   The VDS in the protected header is necessary to understand the VDP in
   the unprotected header.

   The EDN for the Protected Header in the example above is:

   {                                   / Protected                     /
     1: -7,                            / Algorithm                     /
     4: h'68747470...6d706c65',        / Key identifier                /
     395: 1,                           / Verifiable Data Structure     /
   }

      Figure 12: Example consistency receipt decoded protected header

   The EDN for the consistency proof in the Unprotected Header is:

   [                                   / Consistency proof 1           /
     4,                                / Tree size 1                   /
     6,                                / Tree size 2                   /
     [                                 / Consistency hashes (2)        /
        h'0bdaaed3...32568964'         / Intermediate hash 1           /
        h'75f177fd...2e73a8ab'         / Intermediate hash 2           /
     ]
   ]

      Figure 13: Example consistency receipt decoded consistency proof

   The VDS in the protected header is necessary to understand the
   consistency proof structure in the unprotected header.

   The signature and consistency proof are verified in order.

   First the verifier checks the signature on the COSE Sign1.  If the
   verification fails, the consistency proof is not checked.  Second the
   consistency proof is checked by applying a previous inclusion proof,
   to the consistency proof.  If the verification fails, the append only
   property of the verifiable data structure is not assured.  This
   approach is specific to RFC9162_SHA256, different verifiable data
   structures may not support consistency proofs.  It is recommended
   that implementations return a single boolean result for Receipt
   verification operations, to reduce the chance of accepting a valid
   signature over an invalid consistency proof.

6.  Privacy Considerations

   See the privacy considerations section of:

   *  [RFC9162]

   *  [RFC9053]

6.1.  Log Length

   Some structures and proofs leak the size of the log at the time of
   inclusion.  In the case that a log only stores certain kinds of
   information, this can reveal details that could impact reputation.
   For example, if a transparency log only stored breach notices, a
   receipt for a breach notice would reveal the number of previous
   breaches at the time the notice was made transparent.

6.2.  Header Parameters

   Additional header parameters can reveal information about the
   transparency service or its log entries.  A privacy analysis MUST be
   performed for all mandatory fields in profiles based on this
   specification.

7.  Security Considerations

   See the security considerations section of:

   *  [RFC9162]

   *  [RFC9053]

7.1.  Choice of Signature Algorithms

   A security analysis MUST be performed to ensure that the digital
   signature algorithm alg has the appropriate strength to secure
   receipts.

   It is recommended to select signature algorithms that share
   cryptographic components with the verifiable data structure used, for
   example: Both RFC9162_SHA256 and ES256 depend on the sha-256 hash
   function.

7.2.  Validity Period

   In some cases, receipts MAY include strict validity periods, for
   example, activation not too far in the future, or expiration, not too
   far in the past.  See the iat, nbf, and exp claims in [RFC8392], for
   one way to accomplish this.  The details of expressing validity
   periods are out of scope for this document.

7.3.  Status Updates

   In some cases, receipts should be "revocable" or "suspendible", after
   being issued, regardless of their validity period.  The details of
   expressing statuses are out of scope for this document.

8.  Acknowledgements

   We would like to thank Maik Riechert, Jon Geater, Mike Jones, Mike
   Prorock, Ilari Liusvaara, for their contributions (some of which
   substantial) to this draft and to the initial set of implementations.

9.  IANA Considerations

9.1.  Additions to Existing Registries

9.1.1.  New Entries to the COSE Header Parameters Registry

   This document requests IANA to add new values to the 'COSE Header
   Parameters' registries in the 'Integer values between 1 and 255'
   range with 'Specification Required' Registration Procedure.

9.1.1.1.  COSE Header Parameters

9.1.1.1.1.  Receipts

   *  Name: receipts

   *  Label: TBD_0 (requested assignment 394)

   *  Value type: array (of bstr)

   *  Value registry: https://www.iana.org/assignments/cose/
      cose.xhtml#header-parameters

   *  Description: Priority ordered list of CBOR encoded Receipts.

   *  Reference: RFC XXXX

9.1.1.1.2.  Verifiable Data Structure

   *  Name: vds

   *  Label: TBD_1 (requested assignment 395)

   *  Value type: int

   *  Value registry: https://www.iana.org/assignments/cose/
      cose.xhtml#header-parameters

   *  Description: Algorithm name for verifiable data structure, used to
      produce verifiable data structure proofs.

   *  Reference: RFC XXXX

9.1.1.1.3.  Verifiable Data Structure Proofs

   *  Name: vdp (requested assignment 396)

   *  Label: TBD_2

   *  Value type: map

   *  Value registry: https://www.iana.org/assignments/cose/
      cose.xhtml#header-parameters

   *  Description: Location for verifiable data structure proofs in COSE
      Header Parameters.

   *  Reference: RFC XXXX

9.1.2.  COSE Verifiable Data Structures

   IANA will be asked to establish a registry of verifiable data
   structure identifiers, named "COSE Verifiable Data Structures" to be
   administered under a Specification Required policy [RFC8126].

   Template:

   *  Name: The name of the verifiable data structure

   *  Value: The identifier for the verifiable data structure

   *  Description: A brief description of the verifiable data structure

   *  Reference: Where the verifiable data structure is defined

   Initial contents: Provided in Table 1

9.1.2.1.  Expert Review

   This IANA registries is established under a Specification Required
   policy.

   This section gives some general guidelines for what the experts
   should be looking for, but they are being designated as experts for a
   reason, so they should be given substantial latitude.

   Expert reviewers should take into consideration the following points:

   *  Point squatting should be discouraged.  Reviewers are encouraged
      to get sufficient information for registration requests to ensure
      that the usage is not going to duplicate one that is already
      registered, and that the point is likely to be used in
      deployments.

   *  Specifications are required for all point assignments.  Early
      Allocation is permissible, see Section 2 of [RFC7120].
      Provisional assignments to expired drafts MUST be removed from the
      registry.

   *  Points assigned in this registry MUST have references that match
      the COSE Verifiable Data Structure Parameters registry.  It is not
      permissible to assign points in this registry, for which no
      Verifiable Data Structure Parameters entries exist.

9.1.3.  COSE Verifiable Data Structure Parameters

   IANA will be asked to establish a registry of verifiable data
   structure parameters, named "COSE Verifiable Data Structure
   Parameters" to be administered under a Specification Required policy
   [RFC8126].

   Template:

   *  Verifiable Data Structure: The identifier for the verifiable data
      structure

   *  Name: The name of the proof type

   *  Label: The integer of the proof type

   *  CBOR Type: The cbor data type of the proof

   *  Description: The description of the proof type

   *  Reference: Where the proof type is defined

   Initial contents: Provided in Table 3

9.1.3.1.  Expert Review

   This IANA registries is established under a Specification Required
   policy.

   This section gives some general guidelines for what the experts
   should be looking for, but they are being designated as experts for a
   reason, so they should be given substantial latitude.

   Expert reviewers should take into consideration the following points:

   *  Point squatting should be discouraged.  Reviewers are encouraged
      to get sufficient information for registration requests to ensure
      that the usage is not going to duplicate one that is already
      registered, and that the point is likely to be used in
      deployments.

   *  Specifications are required for all point assignments.  Early
      Allocation is permissible, see Section 2 of [RFC7120].
      Provisional assignments to expired drafts MUST be removed from the
      registry.

   *  Points assigned in this registry MUST have references that match
      the COSE Verifiable Data Structures registry.  It is not
      permissible to assign points in this registry, for which no
      Verifiable Data Structure entry exists.

10.  References

10.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC7049]  Bormann, C. and P. Hoffman, "Concise Binary Object
              Representation (CBOR)", RFC 7049, DOI 10.17487/RFC7049,
              October 2013, <https://www.rfc-editor.org/rfc/rfc7049>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC9053]  Schaad, J., "CBOR Object Signing and Encryption (COSE):
              Initial Algorithms", RFC 9053, DOI 10.17487/RFC9053,
              August 2022, <https://www.rfc-editor.org/rfc/rfc9053>.

   [RFC9162]  Laurie, B., Messeri, E., and R. Stradling, "Certificate
              Transparency Version 2.0", RFC 9162, DOI 10.17487/RFC9162,
              December 2021, <https://www.rfc-editor.org/rfc/rfc9162>.

10.2.  Informative References

   [BCP205]   Sheffer, Y. and A. Farrel, "Improving Awareness of Running
              Code: The Implementation Status Section", BCP 205,
              RFC 7942, DOI 10.17487/RFC7942, July 2016,
              <https://www.rfc-editor.org/rfc/rfc7942>.

   [I-D.draft-ietf-cbor-edn-literals]
              Bormann, C., "CBOR Extended Diagnostic Notation (EDN)",
              Work in Progress, Internet-Draft, draft-ietf-cbor-edn-
              literals-12, 1 September 2024,
              <https://datatracker.ietf.org/doc/html/draft-ietf-cbor-
              edn-literals-12>.

   [I-D.ietf-cose-cwt-claims-in-headers]
              Looker, T. and M. B. Jones, "CBOR Web Token (CWT) Claims
              in COSE Headers", Work in Progress, Internet-Draft, draft-
              ietf-cose-cwt-claims-in-headers-10, 29 November 2023,
              <https://datatracker.ietf.org/doc/html/draft-ietf-cose-
              cwt-claims-in-headers-10>.

   [I-D.ietf-cose-typ-header-parameter]
              Jones, M. B. and O. Steele, "COSE "typ" (type) Header
              Parameter", Work in Progress, Internet-Draft, draft-ietf-
              cose-typ-header-parameter-05, 3 April 2024,
              <https://datatracker.ietf.org/doc/html/draft-ietf-cose-
              typ-header-parameter-05>.

   [RFC7120]  Cotton, M., "Early IANA Allocation of Standards Track Code
              Points", BCP 100, RFC 7120, DOI 10.17487/RFC7120, January
              2014, <https://www.rfc-editor.org/rfc/rfc7120>.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/rfc/rfc8126>.

   [RFC8392]  Jones, M., Wahlstroem, E., Erdtman, S., and H. Tschofenig,
              "CBOR Web Token (CWT)", RFC 8392, DOI 10.17487/RFC8392,
              May 2018, <https://www.rfc-editor.org/rfc/rfc8392>.

   [RFC8610]  Birkholz, H., Vigano, C., and C. Bormann, "Concise Data
              Definition Language (CDDL): A Notational Convention to
              Express Concise Binary Object Representation (CBOR) and
              JSON Data Structures", RFC 8610, DOI 10.17487/RFC8610,
              June 2019, <https://www.rfc-editor.org/rfc/rfc8610>.

   [RFC8949]  Bormann, C. and P. Hoffman, "Concise Binary Object
              Representation (CBOR)", STD 94, RFC 8949,
              DOI 10.17487/RFC8949, December 2020,
              <https://www.rfc-editor.org/rfc/rfc8949>.

   [RFC9052]  Schaad, J., "CBOR Object Signing and Encryption (COSE):
              Structures and Process", STD 96, RFC 9052,
              DOI 10.17487/RFC9052, August 2022,
              <https://www.rfc-editor.org/rfc/rfc9052>.

Appendix A.  Implementation Status

   Note to RFC Editor: Please remove this section as well as references
   to [BCP205] before AUTH48.

   This section records the status of known implementations of the
   protocol defined by this specification at the time of posting of this
   Internet-Draft, and is based on a proposal described in [BCP205].
   The description of implementations in this section is intended to
   assist the IETF in its decision processes in progressing drafts to
   RFCs.  Please note that the listing of any individual implementation
   here does not imply endorsement by the IETF.  Furthermore, no effort
   has been spent to verify the information presented here that was
   supplied by IETF contributors.  This is not intended as, and must not
   be construed to be, a catalog of available implementations or their
   features.  Readers are advised to note that other implementations may
   exist.

   According to [BCP205], "this will allow reviewers and working groups
   to assign due consideration to documents that have the benefit of
   running code, which may serve as evidence of valuable experimentation
   and feedback that have made the implemented protocols more mature.
   It is up to the individual working groups to use this information as
   they see fit".

A.1.  Implementer

   An open-source implementation was initiated and is maintained by the
   Transmute Industries Inc. - Transmute.

A.2.  Implementation Name

   An application demonstrating the concepts is available at COSE SCITT
   Receipts (https://github.com/transmute-industries/cose?tab=readme-ov-
   file#scitt-receipts)

A.3.  Implementation URL

   An open-source implementation is available at:

   *  https://github.com/transmute-industries/cose

A.4.  Maturity

   The code's level of maturity is considered to be "prototype".

A.5.  Coverage and Version Compatibility

   The current version ('main') implements the verifiable data structure
   algorithm, inclusion proof and consistency proof concepts of this
   draft.

A.6.  License

   The project and all corresponding code and data maintained on GitHub
   are provided under the Apache License, version 2.

A.7.  Implementation Dependencies

   The implementation uses the Concise Binary Object Representation
   [RFC7049] (https://cbor.io/).

   The implementation uses the CBOR Object Signing and Encryption
   [RFC9053], maintained at: - https://github.com/erdtman/cose-js

   The implementation uses an implementation of [RFC9162], maintained
   at:

   *  https://github.com/transmute-industries/rfc9162/tree/main/src/
      CoMETRE

A.8.  Contact

   Orie Steele (orie@transmute.industries)

Authors' Addresses

   Orie Steele
   Transmute
   United States
   Email: orie@transmute.industries


   Henk Birkholz
   Fraunhofer SIT
   Rheinstrasse 75
   64295 Darmstadt
   Germany
   Email: henk.birkholz@sit.fraunhofer.de


   Antoine Delignat-Lavaud
   Microsoft
   United Kingdom
   Email: antdl@microsoft.com


   Cedric Fournet
   Microsoft
   United Kingdom
   Email: fournet@microsoft.com
